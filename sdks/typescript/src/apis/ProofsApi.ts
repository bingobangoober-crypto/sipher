/* tslint:disable */
/* eslint-disable */
/**
 * Sipher — Privacy-as-a-Skill API
 * REST API wrapping SIP Protocol\'s privacy SDK for Solana agents. Stealth addresses, Pedersen commitments, shielded transfers, and viewing key compliance.
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: hello@sip-protocol.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CommitmentVerify200Response,
  GetHealth503Response,
  ProofsFulfillmentGenerate200Response,
  ProofsFulfillmentGenerateRequest,
  ProofsFulfillmentVerifyRequest,
  ProofsFundingGenerate200Response,
  ProofsFundingGenerateRequest,
  ProofsFundingVerifyRequest,
  ProofsRangeGenerate200Response,
  ProofsRangeGenerateRequest,
  ProofsRangeVerifyRequest,
  ProofsValidityGenerate200Response,
  ProofsValidityGenerateRequest,
  ProofsValidityVerifyRequest,
} from '../models/index';
import {
    CommitmentVerify200ResponseFromJSON,
    CommitmentVerify200ResponseToJSON,
    GetHealth503ResponseFromJSON,
    GetHealth503ResponseToJSON,
    ProofsFulfillmentGenerate200ResponseFromJSON,
    ProofsFulfillmentGenerate200ResponseToJSON,
    ProofsFulfillmentGenerateRequestFromJSON,
    ProofsFulfillmentGenerateRequestToJSON,
    ProofsFulfillmentVerifyRequestFromJSON,
    ProofsFulfillmentVerifyRequestToJSON,
    ProofsFundingGenerate200ResponseFromJSON,
    ProofsFundingGenerate200ResponseToJSON,
    ProofsFundingGenerateRequestFromJSON,
    ProofsFundingGenerateRequestToJSON,
    ProofsFundingVerifyRequestFromJSON,
    ProofsFundingVerifyRequestToJSON,
    ProofsRangeGenerate200ResponseFromJSON,
    ProofsRangeGenerate200ResponseToJSON,
    ProofsRangeGenerateRequestFromJSON,
    ProofsRangeGenerateRequestToJSON,
    ProofsRangeVerifyRequestFromJSON,
    ProofsRangeVerifyRequestToJSON,
    ProofsValidityGenerate200ResponseFromJSON,
    ProofsValidityGenerate200ResponseToJSON,
    ProofsValidityGenerateRequestFromJSON,
    ProofsValidityGenerateRequestToJSON,
    ProofsValidityVerifyRequestFromJSON,
    ProofsValidityVerifyRequestToJSON,
} from '../models/index';

export interface ProofsFulfillmentGenerateOperationRequest {
    proofsFulfillmentGenerateRequest: ProofsFulfillmentGenerateRequest;
}

export interface ProofsFulfillmentVerifyOperationRequest {
    proofsFulfillmentVerifyRequest: ProofsFulfillmentVerifyRequest;
}

export interface ProofsFundingGenerateOperationRequest {
    proofsFundingGenerateRequest: ProofsFundingGenerateRequest;
}

export interface ProofsFundingVerifyOperationRequest {
    proofsFundingVerifyRequest: ProofsFundingVerifyRequest;
}

export interface ProofsRangeGenerateOperationRequest {
    proofsRangeGenerateRequest: ProofsRangeGenerateRequest;
}

export interface ProofsRangeVerifyOperationRequest {
    proofsRangeVerifyRequest: ProofsRangeVerifyRequest;
}

export interface ProofsValidityGenerateOperationRequest {
    proofsValidityGenerateRequest: ProofsValidityGenerateRequest;
}

export interface ProofsValidityVerifyOperationRequest {
    proofsValidityVerifyRequest: ProofsValidityVerifyRequest;
}

/**
 * ProofsApi - interface
 * 
 * @export
 * @interface ProofsApiInterface
 */
export interface ProofsApiInterface {
    /**
     * Generates a ZK proof that the solver delivered output >= minimum to the correct recipient.
     * @summary Generate fulfillment proof
     * @param {ProofsFulfillmentGenerateRequest} proofsFulfillmentGenerateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsFulfillmentGenerateRaw(requestParameters: ProofsFulfillmentGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsFulfillmentGenerate200Response>>;

    /**
     * Generates a ZK proof that the solver delivered output >= minimum to the correct recipient.
     * Generate fulfillment proof
     */
    proofsFulfillmentGenerate(proofsFulfillmentGenerateRequest: ProofsFulfillmentGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsFulfillmentGenerate200Response>;

    /**
     * Verifies a previously generated fulfillment proof.
     * @summary Verify fulfillment proof
     * @param {ProofsFulfillmentVerifyRequest} proofsFulfillmentVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsFulfillmentVerifyRaw(requestParameters: ProofsFulfillmentVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>>;

    /**
     * Verifies a previously generated fulfillment proof.
     * Verify fulfillment proof
     */
    proofsFulfillmentVerify(proofsFulfillmentVerifyRequest: ProofsFulfillmentVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response>;

    /**
     * Generates a ZK proof that balance >= minimumRequired without revealing the balance.
     * @summary Generate funding proof
     * @param {ProofsFundingGenerateRequest} proofsFundingGenerateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsFundingGenerateRaw(requestParameters: ProofsFundingGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsFundingGenerate200Response>>;

    /**
     * Generates a ZK proof that balance >= minimumRequired without revealing the balance.
     * Generate funding proof
     */
    proofsFundingGenerate(proofsFundingGenerateRequest: ProofsFundingGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsFundingGenerate200Response>;

    /**
     * Verifies a previously generated funding proof.
     * @summary Verify funding proof
     * @param {ProofsFundingVerifyRequest} proofsFundingVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsFundingVerifyRaw(requestParameters: ProofsFundingVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>>;

    /**
     * Verifies a previously generated funding proof.
     * Verify funding proof
     */
    proofsFundingVerify(proofsFundingVerifyRequest: ProofsFundingVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response>;

    /**
     * Generates a STARK-based range proof that value >= threshold on a Pedersen commitment without revealing the value. Uses M31 limb decomposition. Currently uses a mock STARK prover — real Murkl integration coming soon.
     * @summary Generate STARK range proof
     * @param {ProofsRangeGenerateRequest} proofsRangeGenerateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsRangeGenerateRaw(requestParameters: ProofsRangeGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsRangeGenerate200Response>>;

    /**
     * Generates a STARK-based range proof that value >= threshold on a Pedersen commitment without revealing the value. Uses M31 limb decomposition. Currently uses a mock STARK prover — real Murkl integration coming soon.
     * Generate STARK range proof
     */
    proofsRangeGenerate(proofsRangeGenerateRequest: ProofsRangeGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsRangeGenerate200Response>;

    /**
     * Verifies a previously generated STARK range proof.
     * @summary Verify STARK range proof
     * @param {ProofsRangeVerifyRequest} proofsRangeVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsRangeVerifyRaw(requestParameters: ProofsRangeVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>>;

    /**
     * Verifies a previously generated STARK range proof.
     * Verify STARK range proof
     */
    proofsRangeVerify(proofsRangeVerifyRequest: ProofsRangeVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response>;

    /**
     * Generates a ZK proof that an intent is authorized by the sender without revealing the sender.
     * @summary Generate validity proof
     * @param {ProofsValidityGenerateRequest} proofsValidityGenerateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsValidityGenerateRaw(requestParameters: ProofsValidityGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsValidityGenerate200Response>>;

    /**
     * Generates a ZK proof that an intent is authorized by the sender without revealing the sender.
     * Generate validity proof
     */
    proofsValidityGenerate(proofsValidityGenerateRequest: ProofsValidityGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsValidityGenerate200Response>;

    /**
     * Verifies a previously generated validity proof.
     * @summary Verify validity proof
     * @param {ProofsValidityVerifyRequest} proofsValidityVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofsApiInterface
     */
    proofsValidityVerifyRaw(requestParameters: ProofsValidityVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>>;

    /**
     * Verifies a previously generated validity proof.
     * Verify validity proof
     */
    proofsValidityVerify(proofsValidityVerifyRequest: ProofsValidityVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response>;

}

/**
 * 
 */
export class ProofsApi extends runtime.BaseAPI implements ProofsApiInterface {

    /**
     * Generates a ZK proof that the solver delivered output >= minimum to the correct recipient.
     * Generate fulfillment proof
     */
    async proofsFulfillmentGenerateRaw(requestParameters: ProofsFulfillmentGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsFulfillmentGenerate200Response>> {
        if (requestParameters['proofsFulfillmentGenerateRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsFulfillmentGenerateRequest',
                'Required parameter "proofsFulfillmentGenerateRequest" was null or undefined when calling proofsFulfillmentGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/fulfillment/generate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsFulfillmentGenerateRequestToJSON(requestParameters['proofsFulfillmentGenerateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProofsFulfillmentGenerate200ResponseFromJSON(jsonValue));
    }

    /**
     * Generates a ZK proof that the solver delivered output >= minimum to the correct recipient.
     * Generate fulfillment proof
     */
    async proofsFulfillmentGenerate(proofsFulfillmentGenerateRequest: ProofsFulfillmentGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsFulfillmentGenerate200Response> {
        const response = await this.proofsFulfillmentGenerateRaw({ proofsFulfillmentGenerateRequest: proofsFulfillmentGenerateRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Verifies a previously generated fulfillment proof.
     * Verify fulfillment proof
     */
    async proofsFulfillmentVerifyRaw(requestParameters: ProofsFulfillmentVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>> {
        if (requestParameters['proofsFulfillmentVerifyRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsFulfillmentVerifyRequest',
                'Required parameter "proofsFulfillmentVerifyRequest" was null or undefined when calling proofsFulfillmentVerify().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/fulfillment/verify`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsFulfillmentVerifyRequestToJSON(requestParameters['proofsFulfillmentVerifyRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitmentVerify200ResponseFromJSON(jsonValue));
    }

    /**
     * Verifies a previously generated fulfillment proof.
     * Verify fulfillment proof
     */
    async proofsFulfillmentVerify(proofsFulfillmentVerifyRequest: ProofsFulfillmentVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response> {
        const response = await this.proofsFulfillmentVerifyRaw({ proofsFulfillmentVerifyRequest: proofsFulfillmentVerifyRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Generates a ZK proof that balance >= minimumRequired without revealing the balance.
     * Generate funding proof
     */
    async proofsFundingGenerateRaw(requestParameters: ProofsFundingGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsFundingGenerate200Response>> {
        if (requestParameters['proofsFundingGenerateRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsFundingGenerateRequest',
                'Required parameter "proofsFundingGenerateRequest" was null or undefined when calling proofsFundingGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/funding/generate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsFundingGenerateRequestToJSON(requestParameters['proofsFundingGenerateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProofsFundingGenerate200ResponseFromJSON(jsonValue));
    }

    /**
     * Generates a ZK proof that balance >= minimumRequired without revealing the balance.
     * Generate funding proof
     */
    async proofsFundingGenerate(proofsFundingGenerateRequest: ProofsFundingGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsFundingGenerate200Response> {
        const response = await this.proofsFundingGenerateRaw({ proofsFundingGenerateRequest: proofsFundingGenerateRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Verifies a previously generated funding proof.
     * Verify funding proof
     */
    async proofsFundingVerifyRaw(requestParameters: ProofsFundingVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>> {
        if (requestParameters['proofsFundingVerifyRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsFundingVerifyRequest',
                'Required parameter "proofsFundingVerifyRequest" was null or undefined when calling proofsFundingVerify().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/funding/verify`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsFundingVerifyRequestToJSON(requestParameters['proofsFundingVerifyRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitmentVerify200ResponseFromJSON(jsonValue));
    }

    /**
     * Verifies a previously generated funding proof.
     * Verify funding proof
     */
    async proofsFundingVerify(proofsFundingVerifyRequest: ProofsFundingVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response> {
        const response = await this.proofsFundingVerifyRaw({ proofsFundingVerifyRequest: proofsFundingVerifyRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Generates a STARK-based range proof that value >= threshold on a Pedersen commitment without revealing the value. Uses M31 limb decomposition. Currently uses a mock STARK prover — real Murkl integration coming soon.
     * Generate STARK range proof
     */
    async proofsRangeGenerateRaw(requestParameters: ProofsRangeGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsRangeGenerate200Response>> {
        if (requestParameters['proofsRangeGenerateRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsRangeGenerateRequest',
                'Required parameter "proofsRangeGenerateRequest" was null or undefined when calling proofsRangeGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/range/generate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsRangeGenerateRequestToJSON(requestParameters['proofsRangeGenerateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProofsRangeGenerate200ResponseFromJSON(jsonValue));
    }

    /**
     * Generates a STARK-based range proof that value >= threshold on a Pedersen commitment without revealing the value. Uses M31 limb decomposition. Currently uses a mock STARK prover — real Murkl integration coming soon.
     * Generate STARK range proof
     */
    async proofsRangeGenerate(proofsRangeGenerateRequest: ProofsRangeGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsRangeGenerate200Response> {
        const response = await this.proofsRangeGenerateRaw({ proofsRangeGenerateRequest: proofsRangeGenerateRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Verifies a previously generated STARK range proof.
     * Verify STARK range proof
     */
    async proofsRangeVerifyRaw(requestParameters: ProofsRangeVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>> {
        if (requestParameters['proofsRangeVerifyRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsRangeVerifyRequest',
                'Required parameter "proofsRangeVerifyRequest" was null or undefined when calling proofsRangeVerify().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/range/verify`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsRangeVerifyRequestToJSON(requestParameters['proofsRangeVerifyRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitmentVerify200ResponseFromJSON(jsonValue));
    }

    /**
     * Verifies a previously generated STARK range proof.
     * Verify STARK range proof
     */
    async proofsRangeVerify(proofsRangeVerifyRequest: ProofsRangeVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response> {
        const response = await this.proofsRangeVerifyRaw({ proofsRangeVerifyRequest: proofsRangeVerifyRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Generates a ZK proof that an intent is authorized by the sender without revealing the sender.
     * Generate validity proof
     */
    async proofsValidityGenerateRaw(requestParameters: ProofsValidityGenerateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProofsValidityGenerate200Response>> {
        if (requestParameters['proofsValidityGenerateRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsValidityGenerateRequest',
                'Required parameter "proofsValidityGenerateRequest" was null or undefined when calling proofsValidityGenerate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/validity/generate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsValidityGenerateRequestToJSON(requestParameters['proofsValidityGenerateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProofsValidityGenerate200ResponseFromJSON(jsonValue));
    }

    /**
     * Generates a ZK proof that an intent is authorized by the sender without revealing the sender.
     * Generate validity proof
     */
    async proofsValidityGenerate(proofsValidityGenerateRequest: ProofsValidityGenerateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProofsValidityGenerate200Response> {
        const response = await this.proofsValidityGenerateRaw({ proofsValidityGenerateRequest: proofsValidityGenerateRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Verifies a previously generated validity proof.
     * Verify validity proof
     */
    async proofsValidityVerifyRaw(requestParameters: ProofsValidityVerifyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CommitmentVerify200Response>> {
        if (requestParameters['proofsValidityVerifyRequest'] == null) {
            throw new runtime.RequiredError(
                'proofsValidityVerifyRequest',
                'Required parameter "proofsValidityVerifyRequest" was null or undefined when calling proofsValidityVerify().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/proofs/validity/verify`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProofsValidityVerifyRequestToJSON(requestParameters['proofsValidityVerifyRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommitmentVerify200ResponseFromJSON(jsonValue));
    }

    /**
     * Verifies a previously generated validity proof.
     * Verify validity proof
     */
    async proofsValidityVerify(proofsValidityVerifyRequest: ProofsValidityVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CommitmentVerify200Response> {
        const response = await this.proofsValidityVerifyRaw({ proofsValidityVerifyRequest: proofsValidityVerifyRequest }, initOverrides);
        return await response.value();
    }

}
