/* tslint:disable */
/* eslint-disable */
/**
 * Sipher — Privacy-as-a-Skill API
 * REST API wrapping SIP Protocol\'s privacy SDK for Solana agents. Stealth addresses, Pedersen commitments, shielded transfers, and viewing key compliance.
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: hello@sip-protocol.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  EncryptBallot200Response,
  EncryptBallotRequest,
  GetHealth503Response,
  GetTally200Response,
  SubmitBallot200Response,
  SubmitBallotRequest,
  TallyVotes200Response,
  TallyVotesRequest,
} from '../models/index';
import {
    EncryptBallot200ResponseFromJSON,
    EncryptBallot200ResponseToJSON,
    EncryptBallotRequestFromJSON,
    EncryptBallotRequestToJSON,
    GetHealth503ResponseFromJSON,
    GetHealth503ResponseToJSON,
    GetTally200ResponseFromJSON,
    GetTally200ResponseToJSON,
    SubmitBallot200ResponseFromJSON,
    SubmitBallot200ResponseToJSON,
    SubmitBallotRequestFromJSON,
    SubmitBallotRequestToJSON,
    TallyVotes200ResponseFromJSON,
    TallyVotes200ResponseToJSON,
    TallyVotesRequestFromJSON,
    TallyVotesRequestToJSON,
} from '../models/index';

export interface EncryptBallotOperationRequest {
    encryptBallotRequest: EncryptBallotRequest;
}

export interface GetTallyRequest {
    id: string;
}

export interface SubmitBallotOperationRequest {
    submitBallotRequest: SubmitBallotRequest;
    idempotencyKey?: string;
}

export interface TallyVotesOperationRequest {
    tallyVotesRequest: TallyVotesRequest;
    idempotencyKey?: string;
}

/**
 * GovernanceApi - interface
 * 
 * @export
 * @interface GovernanceApiInterface
 */
export interface GovernanceApiInterface {
    /**
     * Creates a Pedersen commitment for a vote (yes/no/abstain) and generates a deterministic nullifier from the voter secret + proposal ID. The nullifier prevents double-voting without revealing voter identity.
     * @summary Encrypt a vote ballot
     * @param {EncryptBallotRequest} encryptBallotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApiInterface
     */
    encryptBallotRaw(requestParameters: EncryptBallotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncryptBallot200Response>>;

    /**
     * Creates a Pedersen commitment for a vote (yes/no/abstain) and generates a deterministic nullifier from the voter secret + proposal ID. The nullifier prevents double-voting without revealing voter identity.
     * Encrypt a vote ballot
     */
    encryptBallot(encryptBallotRequest: EncryptBallotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncryptBallot200Response>;

    /**
     * Retrieves a previously computed tally result by its ID. Includes vote counts, the homomorphic tally commitment, and the verification proof.
     * @summary Get tally result
     * @param {string} id Tally ID returned from POST /v1/governance/tally
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApiInterface
     */
    getTallyRaw(requestParameters: GetTallyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTally200Response>>;

    /**
     * Retrieves a previously computed tally result by its ID. Includes vote counts, the homomorphic tally commitment, and the verification proof.
     * Get tally result
     */
    getTally(id: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTally200Response>;

    /**
     * Submits an encrypted ballot (commitment + nullifier) to a proposal. The nullifier is checked for uniqueness — duplicate votes are rejected with 409. Proposals are created lazily on first ballot submission.
     * @summary Submit encrypted ballot to a proposal
     * @param {SubmitBallotRequest} submitBallotRequest 
     * @param {string} [idempotencyKey] UUID v4 for idempotent submission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApiInterface
     */
    submitBallotRaw(requestParameters: SubmitBallotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmitBallot200Response>>;

    /**
     * Submits an encrypted ballot (commitment + nullifier) to a proposal. The nullifier is checked for uniqueness — duplicate votes are rejected with 409. Proposals are created lazily on first ballot submission.
     * Submit encrypted ballot to a proposal
     */
    submitBallot(submitBallotRequest: SubmitBallotRequest, idempotencyKey?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmitBallot200Response>;

    /**
     * Performs homomorphic addition of all ballot commitments for a proposal. The tally commitment can be verified against the total yes-vote count using the combined blinding factor. Returns a verification hash as proof of correct tallying.
     * @summary Tally votes for a proposal
     * @param {TallyVotesRequest} tallyVotesRequest 
     * @param {string} [idempotencyKey] UUID v4 for idempotent tally
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GovernanceApiInterface
     */
    tallyVotesRaw(requestParameters: TallyVotesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TallyVotes200Response>>;

    /**
     * Performs homomorphic addition of all ballot commitments for a proposal. The tally commitment can be verified against the total yes-vote count using the combined blinding factor. Returns a verification hash as proof of correct tallying.
     * Tally votes for a proposal
     */
    tallyVotes(tallyVotesRequest: TallyVotesRequest, idempotencyKey?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TallyVotes200Response>;

}

/**
 * 
 */
export class GovernanceApi extends runtime.BaseAPI implements GovernanceApiInterface {

    /**
     * Creates a Pedersen commitment for a vote (yes/no/abstain) and generates a deterministic nullifier from the voter secret + proposal ID. The nullifier prevents double-voting without revealing voter identity.
     * Encrypt a vote ballot
     */
    async encryptBallotRaw(requestParameters: EncryptBallotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EncryptBallot200Response>> {
        if (requestParameters['encryptBallotRequest'] == null) {
            throw new runtime.RequiredError(
                'encryptBallotRequest',
                'Required parameter "encryptBallotRequest" was null or undefined when calling encryptBallot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/governance/ballot/encrypt`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EncryptBallotRequestToJSON(requestParameters['encryptBallotRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EncryptBallot200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a Pedersen commitment for a vote (yes/no/abstain) and generates a deterministic nullifier from the voter secret + proposal ID. The nullifier prevents double-voting without revealing voter identity.
     * Encrypt a vote ballot
     */
    async encryptBallot(encryptBallotRequest: EncryptBallotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EncryptBallot200Response> {
        const response = await this.encryptBallotRaw({ encryptBallotRequest: encryptBallotRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a previously computed tally result by its ID. Includes vote counts, the homomorphic tally commitment, and the verification proof.
     * Get tally result
     */
    async getTallyRaw(requestParameters: GetTallyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTally200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getTally().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/governance/tally/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTally200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a previously computed tally result by its ID. Includes vote counts, the homomorphic tally commitment, and the verification proof.
     * Get tally result
     */
    async getTally(id: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTally200Response> {
        const response = await this.getTallyRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Submits an encrypted ballot (commitment + nullifier) to a proposal. The nullifier is checked for uniqueness — duplicate votes are rejected with 409. Proposals are created lazily on first ballot submission.
     * Submit encrypted ballot to a proposal
     */
    async submitBallotRaw(requestParameters: SubmitBallotOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmitBallot200Response>> {
        if (requestParameters['submitBallotRequest'] == null) {
            throw new runtime.RequiredError(
                'submitBallotRequest',
                'Required parameter "submitBallotRequest" was null or undefined when calling submitBallot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['idempotencyKey'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['idempotencyKey']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/governance/ballot/submit`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubmitBallotRequestToJSON(requestParameters['submitBallotRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmitBallot200ResponseFromJSON(jsonValue));
    }

    /**
     * Submits an encrypted ballot (commitment + nullifier) to a proposal. The nullifier is checked for uniqueness — duplicate votes are rejected with 409. Proposals are created lazily on first ballot submission.
     * Submit encrypted ballot to a proposal
     */
    async submitBallot(submitBallotRequest: SubmitBallotRequest, idempotencyKey?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmitBallot200Response> {
        const response = await this.submitBallotRaw({ submitBallotRequest: submitBallotRequest, idempotencyKey: idempotencyKey }, initOverrides);
        return await response.value();
    }

    /**
     * Performs homomorphic addition of all ballot commitments for a proposal. The tally commitment can be verified against the total yes-vote count using the combined blinding factor. Returns a verification hash as proof of correct tallying.
     * Tally votes for a proposal
     */
    async tallyVotesRaw(requestParameters: TallyVotesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TallyVotes200Response>> {
        if (requestParameters['tallyVotesRequest'] == null) {
            throw new runtime.RequiredError(
                'tallyVotesRequest',
                'Required parameter "tallyVotesRequest" was null or undefined when calling tallyVotes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['idempotencyKey'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['idempotencyKey']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/v1/governance/tally`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TallyVotesRequestToJSON(requestParameters['tallyVotesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TallyVotes200ResponseFromJSON(jsonValue));
    }

    /**
     * Performs homomorphic addition of all ballot commitments for a proposal. The tally commitment can be verified against the total yes-vote count using the combined blinding factor. Returns a verification hash as proof of correct tallying.
     * Tally votes for a proposal
     */
    async tallyVotes(tallyVotesRequest: TallyVotesRequest, idempotencyKey?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TallyVotes200Response> {
        const response = await this.tallyVotesRaw({ tallyVotesRequest: tallyVotesRequest, idempotencyKey: idempotencyKey }, initOverrides);
        return await response.value();
    }

}
