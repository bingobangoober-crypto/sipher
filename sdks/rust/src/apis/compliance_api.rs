/*
 * Sipher â€” Privacy-as-a-Skill API
 *
 * REST API wrapping SIP Protocol's privacy SDK for Solana agents. Stealth addresses, Pedersen commitments, shielded transfers, and viewing key compliance.
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: hello@sip-protocol.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`compliance_disclose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ComplianceDiscloseError {
    Status400(models::GetHealth503Response),
    Status403(models::GetHealth503Response),
    Status500(models::GetHealth503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`compliance_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ComplianceReportError {
    Status400(models::GetHealth503Response),
    Status403(models::GetHealth503Response),
    Status500(models::GetHealth503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_compliance_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetComplianceReportError {
    Status400(models::GetHealth503Response),
    Status403(models::GetHealth503Response),
    Status404(models::GetHealth503Response),
    UnknownValue(serde_json::Value),
}


/// Creates a selective disclosure for a verified auditor. Derives a scoped viewing key limited to the specified scope, encrypts transaction data, and returns the disclosure record. Requires enterprise tier.
pub async fn compliance_disclose(configuration: &configuration::Configuration, compliance_disclose_request: models::ComplianceDiscloseRequest) -> Result<models::ComplianceDisclose200Response, Error<ComplianceDiscloseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_compliance_disclose_request = compliance_disclose_request;

    let uri_str = format!("{}/v1/compliance/disclose", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    req_builder = req_builder.json(&p_body_compliance_disclose_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComplianceDisclose200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComplianceDisclose200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ComplianceDiscloseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates an encrypted compliance audit report for the specified time range. Verifies auditor identity, produces transaction summaries with encrypted entries, and caches the report for 24 hours. Requires enterprise tier.
pub async fn compliance_report(configuration: &configuration::Configuration, compliance_report_request: models::ComplianceReportRequest) -> Result<models::ComplianceReport200Response, Error<ComplianceReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_compliance_report_request = compliance_report_request;

    let uri_str = format!("{}/v1/compliance/report", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };
    req_builder = req_builder.json(&p_body_compliance_report_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComplianceReport200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComplianceReport200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ComplianceReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a previously generated compliance audit report by ID. Reports are cached for 24 hours after generation. Requires enterprise tier.
pub async fn get_compliance_report(configuration: &configuration::Configuration, id: &str) -> Result<models::GetComplianceReport200Response, Error<GetComplianceReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/compliance/report/{id}", configuration.base_path, id=crate::apis::urlencode(p_path_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetComplianceReport200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetComplianceReport200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetComplianceReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

